name: cloudflared
pgid: 1000
puid: 1000
cloudflare-tunnel:
  cloudflare:
    account: "e389e69d2d04c5adeee066b2192f79d3"
    tunnelName: "argocd"
    tunnelId: "5091c691-74fe-4a9d-8b6f-ebb79ac03aa8"
    secret: "tS8zgazBTA6sLVykLcQm0OpTnDohkvm4+hdRsTAlwas="
    # If true, turn on WARP routing for TCP
    enableWarp: false
    # Define ingress rules for the tunnel. See
    # https://developers.cloudflare.com/cloudflare-one/connections/connect-apps/configuration/configuration-file/ingress
    ingress: []
      # The first rule proxies traffic to the httpbin sample service named web-server at port 80
      # - hostname: tunnel.example.com
      #  service: http://web-service:80
      # This rule sends traffic to the built-in hello-world HTTP server. This can help debug connectivity
      # issues. If hello.example.com resolves and tunnel.example.com does not, then the problem is
      # in the connection from cloudflared to your local service, not from the internet to cloudflared.
      # - hostname: hello.example.com
      #   service: hello_world

      # apiVersion: networking.k8s.io/v1
      # kind: Ingress
      # metadata:
      #   name: {{ .Values.name }}
      #   annotations:
      #     cert-manager.io/cluster-issuer: letsencrypt
      #     external-dns.alpha.kubernetes.io/host: {{ .Values.name }}.k8s.frost.haus
      # spec:
      #   ingressClassName: nginx
      #   tls:
      #   - hosts:
      #     - {{ .Values.name }}.k8s.frost.haus
      #     secretName: {{ .Values.name }}-cert
      #   rules:
      #   - host: {{ .Values.name }}.k8s.frost.haus
      #     http:
      #       paths:
      #       - pathType: ImplementationSpecific
      #         path: "/"
      #         backend:
      #           service:
      #             name: {{ .Values.name }}
      #             port:
      #               name: http

  image:
    repository: cloudflare/cloudflared
    pullPolicy: IfNotPresent
    # If supplied, this overrides "appVersion"
    tag: ""

  replicaCount: 2

  imagePullSecrets: []
  nameOverride: ""
  fullnameOverride: ""

  serviceAccount:
    annotations: {}
    name: ""

  podAnnotations: {}

  podSecurityContext:
    runAsNonRoot: true
    runAsUser: 65532
    sysctls:
    - name: net.ipv4.ping_group_range
      value: "0           200000000"
    - name: net.core.rmem_max
      value: 7500000
    - name: net.core.wmem_max
      value: 7500000

  securityContext:
    allowPrivilegeEscalation: false
    capabilities:
      drop:
      - ALL
    readOnlyRootFilesystem: true

  resources: 
    limits:
      cpu: 100m
      memory: 128Mi
    requests:
      cpu: 100m
      memory: 128Mi